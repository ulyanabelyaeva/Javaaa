Framework - программная платформа

- 1. Понятие шаблона проектирования, составляющие шаблона. Приведите примеры употребления шаблонов в неверных контекстах
    - Паттерн проектирования — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ.
    - В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу.
    - Паттерн представляет собой не какой-то конкретный код, а общую концепцию решения той или иной проблемы, которую нужно будет ещё подстроить под нужды вашей программы.
    - Паттерны часто путают с алгоритмами, ведь оба понятия описывают типовые решения каких-то известных проблем.
    - Но если алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, реализация которого может отличаться в двух разных программах.
    - Если привести аналогии, то алгоритм — это кулинарный рецепт с чёткими шагами, а паттерн — инженерный чертёж, на котором нарисовано решение, но не конкретные шаги его реализации.
    - Описания паттернов обычно очень формальны и чаще всего состоят из таких пунктов:
        - проблема, которую решает паттерн;
        - мотивации к решению проблемы способом, который предлагает паттерн;
        - структуры классов, составляющих решение;
        - примера на одном из языков программирования;
        - особенностей реализации в различных контекстах;
        - связей с другими паттернами.
- 2. Классификация паттернов проектирования, приведите несколько примеров паттернов каждого класса
    - **Порождающие паттерны** – отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.
    Фабричный метод
    Абстрактный метод
    Строитель
    Прототип
    Одиночка
    - **Структурные паттерны** – отвечают за построение удобных в поддержке иерархий классов.
    Адаптер
    Мост
    Компоновщик
    Декоратор
    Фасад
    Легковес
    Заместитель
    - **Поведенческие паттерны** – решают задачи эффективного и безопасного взаимодействия между объектами программы.
    Цепочка обязанностей
    Команда
    Итератор
    Посредник
    Снимок
    Наблюдатель
    Состояние
    Стратегия
    Шаблонный метод
    Посетитель
- 3. Функциональные интерфейсы. Понятие функционального интерфейса и использование в программах на языке Джава
    - **Функциональный интерфейс** – это интерфейс у которого только один абстрактный метод.
    - Функциональный интерфейс может содержать любое количество методов по умолчанию (default) или статических методов.
    - К функциональному интерфейсу можно добавить аннотацию @FunctionalInterface.
        - Это не обязательно, но при наличии данной аннотации код не скомпилируется, если будет больше или меньше, чем один абстрактный метод.

        ```java
        @FunctionalInterface
        public interface Function<T, R> {
        		R apply(T arg);
        }
        ```

    - Если в каком-то методе функциональный интерфейс передан как параметр, то вместо его реализации можно использовать ***лямбда-функцию***,
    что заметно упрощает код, делает его более читаемым.

        ```java
        Function<String, Integer> f = str -> str.length();
        ```

- 4. Определение и использование функциональных интерфейсов. Аннотирование функциональных интерфейсов
    - см вопрос “№3
- 5. Понятие и использование лямбда-выражений в языке Джава. Примеры
    - **Лямбда** - набор инструкций, которые можно выделить в отдельную переменную и затем многократно вызвать в различных местах программы.
    - Их **основная цель** – повысить читабельность и уменьшить количество кода.
    - Основу лямбда-выражения составляет **лямбда-оператор**, который представляет стрелку ->.
    - Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая, собственно, представляет тело лямбда-выражения, где выполняются все действия.
    - Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе.
    - При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.
    - Пример

        ```java
        interface Operationable {
            int calculate(int x, int y);
        }

        // Определение ссылки на функциональный интерфейс
        Operationable operation;

        // Создание лямбда-выражения
        operation = (x,y)-> x+y;

        // Использование лямбда-выражения в виде вызова метода интерфейса
        int result = operation.calculate(10, 20);
        ```

        - В роли функционального интерфейса выступает интерфейс `Operationable`, в котором определен один метод без реализации - метод `calculate`.
        - Данный метод принимает два параметра - целых числа, и возвращает некоторое целое число.
        - Параметры лямбда-выражения соответствуют параметрам единственного метода интерфейса `Operationable`, а результат соответствует возвращаемому результату метода интерфейса.
        - При этом нам не надо использовать ключевое слово `return` для возврата результата из лямбда-выражения.
        - Так, в методе интерфейса оба параметра представляют тип `int`, значит, в теле лямбда-выражения мы можем применить к ним сложение.
        - Результат сложения также представляет тип `int`, объект которого возвращается методом интерфейса.
        - Для одного функционального интерфейса мы можем определить множество лямбда-выражений.
- 6. Паттерн “Стратегия. Пример использования функций для параметризации поведения объектов
    - см. примеры задач

    ---

    - Функции можно хранить в полях класса и использовать для параметризации поведения объектов (паттерн “Стратегия”).
    - **Задача**: иметь для разных объектов разное поведение.
        - Вместо того, чтобы задавать поведение класса с помощью метода, который будет переопределяться у наследников, мы будем хранить это поведение внутри класса, как поле в виде функционального интерфейса.
        - Интерфейс `Supplier` (поле в классе `Animal`) это интерфейс с одним методом `get()` (в данном случае возвращает строку).
        - Теперь можно, не создавая дочерние классы, создавать новое поведение: передавать поведение в конструктор класса `Animal`.

        ```java
        class Animal {
        		private Supplier<String> talk;
        		// Конструктор, принимающий Supplier<String>
        		... System.out.println(talk.get());
        }

        Animal dog = new Animal(() -> “Гав”);
        Animal cat = new Animal(() -> “Мяу”);
        ```

- 7. Понятие чистой функции. Побочные эффекты функций. Чистота функций в ООП. Пример
    - Чистая функция
        - Чистая (pure) функция – функция без побочных эффектов, результат которой зависит только от значений ее параметров.

        ```java
        class Point {
        		private int x;
        		private int y;
        		Point(int x, int y) { this.x = x; this.y = y; }
        		Point move(int dx) {
        				return new Point(this.x + dx, y); // нет побочных эффектов, т.к. создается новый объект
        		}
        		int getX() { return x; }
        }
        // И move, и getX – чистые функции
        // в данном случае this мы считаем неявным параметром функции
        ```

        - В ООП чистота функций (методов) достигается с помощью использования неизменяемых классов
        - Все методы неизменяемого класса являются чистыми
        - После создания объекта неизменяемого класса его состояние больше НЕ МЕНЯЕТСЯ
        - При операциях с такими объектами создаются новые объекты, а не меняются уже существующие
    - Побочные эффекты функций
        - Побочные эффекты функции – то, что делает функция (метод) кроме вычисления результата функции (метода).
        - Наиболее частый побочный эффект – изменение состояния объектов (т.е. изменение значений полей).
        - Ввод/вывод также является побочным эффектом.
        - Часто повторный вызов функции с побочным эффектом производит результат, отличный от предыдущего вызова.

        ```java
        class Point {
        		int x;
        		int y;
        		void move(int dx) {
        				this.x += dx; // побочный эффект (изменение значения переменной x)
        		}
        		int getX() { return x; } // не является чистой, т.к. разные вызовы
        		// могут вернуть разные значения
        }

        Point p1 = new Point(0, 0);
        p1.move(3); // p1.x == 3
        p1.move(3); // p1.x == 6
        ```

- 8. Неизменяемый класс. Преимущества использования неизменяемых классов. Пример
    - **Неизменяемый** (иммутабельный, immutable) класс — это класс, который после инициализации не может изменить свое состояние.
    - То есть если в коде есть ссылка на экземпляр иммутабельного класса, то любые изменения в нем приводят к созданию нового экземпляра.
    - Для того, чтобы гарантировать неизменяемость свойств объекта, следует использовать модификатор `final` для полей.
    - Также неизменяемый класс как правило закрыт для наследования, т.к. иначе класс-наследник может добавит изменяемые поля.
    - Для корректного создания экземпляра в нем должны быть параметризованные конструкторы, через которые осуществляется первоначальная инициализация полей класса.
    - Плюсы неизменяемых объектов
        - 1. Проще понять работу класса
            - 1.1. Отсутствует “действие на расстоянии”

                ```java
                class Point {
                		int x;
                		int y;
                }
                Point p1 = new Point(0, 0);
                Point p2 = p1; // создали ссылочную переменную и инициализировали ее объектом p1
                ...
                p2.x = 10; // p1.x меняется тоже!
                ```

                - так как действие на расстоянии по определению нелокально, то его невозможно отследить, рассматривая только один изолированный участок кода
                - иногда действие на расстоянии полезно, но чаще всего - нет
            - 1.2. Результат работы программы не зависит от истории

                ```java
                class MyClass {
                		private ImportantThing thing;

                		void init(ImportantThing thing) {
                				this.thing = thing;
                		}

                		void work() {
                				thing.doWork();
                		}
                }

                MyClass obj = new MyClass();
                obj.init(new ImportantThing());

                // Если мы забудем вызов init, то здесь будет ошибка:
                obj.work();
                ```

                - Т.е. работоспособность метода зависит от того, какие методы мы вызывали перед этим.
                - Если класс неизменяемый, то инициализация происходит в конструкторе (он обязательно должен быть в неизменяемом классе), и объект сразу инициализируется в правильном расстоянии, поэтому в этом случае мы не можем забыть про инициализацию.
            - 1.3. Проще проверять инварианты класса
                - Инвариант класса – условие, которое должно выполняться на протяжении всего срока жизни объекта.
                - В *неизменяемом классе* ****инвариант достаточно проверять в конструкторе.

                    ```java
                    // Инвариант: a < b
                    class OrderedPair {
                    		private int a;
                    		private int b;

                    		OrderedPair(int a, int b) {
                    		// проверяет инвариант
                    				check(a < b);
                    				this.a = a;
                    				this.b = b;
                    		}
                    }
                    ```

                - В случае **изменяемого объекта** инвариант нужно проверять в каждом методе, изменяющем состояние (mutator method).
                    - Это можно забыть сделать, и инвариант будет нарушен.

                    ```java
                    class OrderedPair {
                    		...

                    		void setA(int newA) {
                    				check(newA < b);
                    				this.a = newA;
                    		}

                    		void setB(int newB) {
                    				check(a < newB);
                    				this.b = newB;
                    		}
                    }
                    ```

        - 2. Проще тестировать класс
            - Благодаря отсутствию зависимости от истории вызванных методов неизменяемые классы проще тестировать – не нужно перед вызовом тестируемого метода вызывать методы, которые приводят объект в нужное состояние – он сразу инициализирован в правильном состоянии
        - 3. Проще использовать в многопоточной среде
            - В языке Java модификатор `final` для полей имеет особый смысл при многопоточной работе: к полю с этим модификатором могут безопасно обращаться одновременно несколько потоков, и они гарантированно будут видеть одинаковое значение.
            - Для `не-final` полей без особой синхронизации потоков может быть так, что каждый поток видит свое значение поля
        - 4. Можно использовать в качестве ключей Map

    ```java
    public final class Point {
    		private final int x;
    		private final int y;

    		public Point(int x, int y) {
    				this.x = x;
    				this.y = y;
    		}
    }
    ```

- 9. Использование неизменяемых полей класса. Преимущества неизменяемых объектов
    - Неизменяемые поля – поля классов, которые помечены как `final`, но не инициализированы.
    - Перед использованием эти поля нужно в любом случае инициализировать (только один раз).
    - Преимущества – Вопрос 8.
- 10. Функциональное программирование. Понятие инварианта класса. Примеры
    - Функциональное программирование — это программирование, в котором функции являются объектами, и их можно присваивать переменным, передавать в качестве аргументов другим функциям, возвращать в качестве результата от функций и т.д.
    - Функциональное программирование удобно еще и тем, что в нем отсуствуют побочные эффекты функций
    - Понятие инварианта – Вопрос 8.
- 11. Особенности многопоточной работы в Джава, использование final для полей данных для обеспечения потокобезопасности
    - см вопрос №8
- 12. Основное назначение паттерна “Строитель” (Builder) для разработки программ на языке Джава
    - см. примеры задач

    ---

    - **Проблема**: у неизменяемых классов создавать объект можно только в “готовом” состоянии через конструктор. Для сложных объектов может понадобиться передать в конструктор много параметров, а в Java значений по умолчанию нет.
    - **Решение**: паттерн `Builder` позволяет использовать изменяемый объект для задания свойств, а затем создания на их основе неизменяемого объекта.
    - Как правило изменяемый `Builder` существует в рамках одного метода и снаружи не виден, так что это не нарушает функциональной чистоты.

    ```java
    class MyServerBuilder {
    	// изменяемые поля, которые мы проинициализировали
    		private int port = 80;
    		private String protocol = “http”;
    		private Path rootDir = Path.of(“web”);

    		void setPort(int port) { this.port = port; }
    		void setProtocol(String protocol) { this.protocol = protocol; }
    		void setRootDir(Path rootDir) { this.rootDir = rootDir; }

    		MyServer build() {
    				return new MyServer(port, protocol, rootDir);
    		}
    }

    MyServerBuilder builder = new MyServerBuilder();
    builder.setPort(8080);
    MyServer server = builder.build();
    ```

- 13. Стандартные функциональные интерфейсы в Джава и их методы:


    |
           Интерфейс |
      Пример  использования
     |
    | --- | --- |
    | Predicate<T> проверяет соблюдение некоторого условия. Если оно соблюдается, то возвращается значение true. В качестве параметрa лямбда-выражение принимает объект типа T
       |
      public interface Predicate<T> {
          boolean test(T t);
      }
      Predicate<Integer> isPositive = x -> x > 0;
      System.out.println(isPositive.test(5));  // true
       |
    | BinaryOperator<T> принимает в качестве параметра два объекта типа T, выполняет над ними бинарную операцию и возвращает ее результат также в виде объекта типа T.
       |
      public interface BinaryOperator<T> {
          T apply(T t1, T t2);
      }
      BinaryOperator<Integer> multiply = (x, y) -> x*y;
      System.out.println(multiply.apply(3, 5)); // 15
       |

    - Лучше определять собственные функциональные интерфейсы, чем использовать стандартные, потому что:
        1. название интерфейса и метода лучше документирует его назначение
        2. можно использовать конткретные типы вместо типовых параметров, что облегчает чтение
        3. в среде разработки будет проще найти реализации этого интерфейса
        4. стандартные интерфейсы не предусматривают checked exceptions
- 14. Потоки Stream API в Джава и их использование
    - **Java Stream API** — это новый инструмент языка Java, который позволяет использовать функциональный стиль при работе с разными структурами данных.
    - Для начала стриму нужен источник, из которого он будет получать объекты. Чаще всего это коллекции, но не всегда. Например, можно взять в качестве источника генератор, у которого заданы правила создания объектов.

    <aside>
    💡 Данные в стриме обрабатываются на промежуточных операциях. Например: мы можем отфильтровать данные, пропустить несколько элементов, ограничить выборку, выполнить сортировку. Затем выполняется терминальная операция. Она поглощает данные и выдает результат.

    </aside>

    - **Задача:** найти сумму нечетных чисел в коллекции.

        Решение с методами стрима:

        ```java
        Integer odd = collection.stream()
        .filter(p -> p % 2 != 0)
        .reduce((c1, c2) -> c1 + c2)
        .orElse(0);
        ```

        - Здесь мы видим функциональный стиль.
        - Без стримов эту же задачу приходится решать через использование цикла:

            ```java
            Integer oldOdd = 0;
            		for(Integer i: collection) {
            				if(i % 2 != 0) {
            				oldOdd += i;
            		}
            }
            ```


    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e1f9561c-0c96-48fe-acc0-772e56e0c0f4/Untitled.png)

    - [https://www.youtube.com/watch?v=IQVwwwSe4Ic](https://www.youtube.com/watch?v=IQVwwwSe4Ic)
- 15. Статический импорт и его использование для программирования Stream API

    ```java
    List<String> names = Arrays.asList(“Иван”, “Джон”, “”, “Хуан”);
    // Нужно составить строку с приветствием непустых имен:
    String greetings = names.stream()
    .filter(name -> !name.isEmpty())
    .map(name -> String.format(“Привет, %s!”, name));
    .collect(joining(“ “));
    ```

    - В приведенном примере предполагается, что используется директива статического импорта:
    `import static java.util.Collectors.joining;`
    - Директивы статического импорта позволяют использовать статические члены класса без указания имени класса, т.е. просто `joining(“ “)` вместо `Collectors.joining(“ “)`.
- 16. Назначение метода stream() интерфейса Collection. Примеры
    - stream() - это превращение последовательности элементов, над которыми можно производить операции - возвращает поток
    - `collection.stream()` – создает поток из элементов коллекции

    ```java
    Collection<String> collection = Arrays.asList("a1", "a2", "a3");
    Stream<String> streamFromCollection = collection.stream();
    ```

- 17. Работа со Stream API. Нетерминальные операции потока Stream<T>:, назначение и использование
    - Нетерминальные операции, или промежуточные – те операции, которые возвращают трансформированный поток данных (их результат является потоком, и к нему в свою очередь можно тоже применить операцию
    - Важная особенность нетерминальных методов – они являются **ленивыми**, т.е. при если у нас есть список из 1 миллиона элементов:
    `List million = ...`
    то вызов
    `million.stream().map(str -> str + “!”)`
    не создает в памяти новый список из миллиона строк, а создает всего лишь новый объект Stream, который знает, что элементы нужно преобразовывать по мере необходимости
- 18. Работа со Stream API. Терминальные операции, назначение и использование. Примеры
    - Терминальные операции возвращают конечный результат и фактически завершают поток (их результат не является потоком).
- 19. Интерфейс Splititerator и его методы
    - **`Java Spliterator**` – это еще один тип интерфейса `Iterator` для навигации по отдельным элементам.
    - Как следует из названия, он поддерживает разделение и итерацию вместе.
    - Это означает, что мы можем выполнять параллельное программирование с помощью `Spliterator`.
    - Преимущества
        1. Поддерживает параллельное программирование
        2. Мы можем использовать его как для последовательной, так и для параллельной обработки элементов данных.
        3. Метод `tryAdvance()` объединяет операции `next()` и `hasNext()` простого итератора и, таким образом, обеспечивает более высокую производительность.
        4. Также важно понимать, что `Spliterator` отлично работает как для источников `Collection`, так и для потоков, но не с реализациями `Map` в качестве источника
    - Чтобы получить экземпляр Java `Spliterator`, мы будем использовать метод `spliterator()`:

        ```java
        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
        Spliterator splitr = list.spliterator();
        ```

- 20. Понятие многопоточности и написание многопоточных программ на языке Джава
    - Многопоточность в Java — это выполнение двух или более потоков одновременно для максимального использования центрального процесса.
    - Все потоки выполняются параллельно друг другу.

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9fce7cf1-028f-4208-966e-6bc73865500e/Untitled.png)

    - Процесс — это совокупность кода и данных, разделяющих общее виртуальное адресное пространство.

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/54b1f591-0416-4260-8b1b-1325a4f1bd1c/Untitled.png)

    - Для каждого отдельного потока не выделяется память, что приводит к ее экономии.
    - Кроме этого, переключение между потоками занимает меньше времени.
    - Преимущества многопоточности
        - В задачах на многопоточность Java потоки выполняются независимо друг от друга, поэтому отсутствует блокирование пользователей, и можно выполнять несколько операций одновременно;
        - Одни потоки не влияют на другие, когда они наталкиваются на исключения.
- атомарная операция - это
    - одновременное обращение только одного потока к объекту, которое нельзя разделить
- **Анонимные классы - это**

    это **классы**, что не имеют имени и их создание происходит в момент инициализации объекта.


---

- 21. Потоки (threads) в Джава. Создание потоков в Джава программах Подходы к созданию потоков: через наследование и реализацию интерфейса Runnable Thread API. Запуск потока с Runnable
    - **Поток** с точки зрения объектной модели **Java** — это объект класса, наследующего класс Thread или реализующего интерфейс Runnable.
    - Один процесс может иметь несколько параллельно выполняющихся потоков.
    - В отличие от процессов, все потоки одного процесса выполняются в одном адресном пространстве, т.е. используют общую память.
    - Потоки используются для:
        1. Ускорения работы программы (напр., суммирование большого массива данных можно ускорить, если разбить его на два подмассива и суммировать их в отдельных потоках)
        2. Систем массового обслуживания (пример: вебсерверы), когда требуется одновременно выполнять много запросов
    - Как создать поток в Джава:
        1. Наследование от класса Thread

            ```java
            // Вызываем конструктора класса Thread и создаем объект
            Thread thread = new Thread();
            // Запускаем поток (метод start)
            thread.start();

            // Выполним методы в потоке:
            // 1)	Подкласс
            public class MyThread extends Thread {
            		public void run() {
            				System.out.println("MyThread running");
            		}
            }

            // 2)	Анонимный класс
            Thread thread = new Thread() {
            		public void run() {
            				System.out.println("Thread Running");
            		}
            }
            thread.start();
            ```

        2. Реализация интерфейса Runnable

            ```java
            public interface Runnable() {
            		public void run();
            }
            ```

            После выполнения метода поток останавливается.

            ```java
            // 1)	Класс, реализующий Runnable
            public class MyRunnable implements Runnable {
            		public void run() {
            				System.out.println("MyRunnable running");
            		}
            }

            // 2)	Анонимная реализация Runnable
            Runnable myRunnable = new Runnable(){
            		public void run() {
            				System.out.println("Runnable running");
            		}
            }

            // 3)	Лямба-выражения
            // Применение возможно, так как у Rannable реализуется один метод.
            Runnable code = () -> {
            		System.out.println(“Lambda Hello Runnable!”);
            };
            code.run();

            // 4) Код, переданный в виде объекта Runnable в конструктор Thread,
            // выполняется в новом потоке параллельно основному потоку программы (main thread)
            Runnable code = () -> {
            		System.out.println(“Hello Runnable!”);
            };
            Thread t1 = new Thread(code);
            t1.start(); // запуск потока
            ```

    - Класс `Thread`

        [https://www.bestprog.net/ru/2021/01/17/java-java-language-tools-for-working-with-threads-ru/](https://www.bestprog.net/ru/2021/01/17/java-java-language-tools-for-working-with-threads-ru/)

        - Класс `Thread` является основным классом при работе с потоками выполнения.
        - Создание любого потока начинается с создания экземпляра класса `Thread`.
        - При этом можно использовать следующие конструкторы класса:
        `Thread(Runnable threadObject)
         Thread(Runnable threadObject, String threadName)`
            - `threadObject` – объект некоторого класса, который нужно выполнить в потоке. Этот объект должен реализовывать интерфейс `Runnable` или расширять класс `Thread`;
            - `threadName` – имя, которое устанавливается для созданного потока исполнения. Это имя может быть прочитано методом `getName()`.
        - В общем случае, код создания потока выполнения с именем «My thread» для объекта класса MyThreadClass выглядит следующим образом:

            ```java
            ...
            // Создать экземпляр класса MyThreadClass
            MyThreadClass threadObject =new MyThreadClass();

            // Создать дочерний поток в главном потоке
            Thread thr =new Thread(threadObject, "My thread");
            ...
            ```

        - Методы класса `Thread`
            - getName() — получить имя потока выполнения;
            - getPriority() — получить приоритет потока выполнения;
            - isAlive() — определить, выполняется ли поток;
            - join() — предназначен для ожидания завершения потока выполнения;
            - run() — задает код, который должен выполняться в потоке выполнения. Это есть точка входа в поток;
            - sleep() — приостанавливает выполнение вызывающего потока выполнения на указанное время;
            - start() — запускает поток выполнения с помощью вызова метода run().
    - main - главный поток (специальный поток, созданный виртуальной машиной джава для запуска приложения), в котором выполняются созданные потоки
    - область кода и данных одна, а стэк для каждого потока - свой
- 22. Потоки в Джава. Методы Thread API

    ```java
    public class Thread {

    		void start(); // запуск потока

    		void run();

    		static Thread currentThread(); // поток, который вызвал этот метод

    		String getName(); // имя потока (можно задать через setName)

    		void setName(String name);

    		void join() throws InterruptedException;

    		void setDaemon(boolean on);

    		static void sleep(long millis) throws InterruptedException;

    		State getState();
    }
    ```

    - Метод `run()`
        - В методе `run()` указывается код, который должен выполняться в потоке.
        - Метод `run()` является точкой входа в поток.
        - Метод `run()`объявлен в интерфейсе `Runnable`.
        - Для того, чтобы в классе инкапсулировать поток выполнения нужно реализовывать интерфейс `Runnable` и переопределять метод `run()` по образцу ниже

            ```java
            class MyThreadClassimplements Runnable {
              // ...
              void run() {
                // код потока
                // ...
              }
            }
            ```

        - Код метода `run()` начинает выполняться только после вызова метода `start()`
        - Общая форма метода `run()` - `void run()`
    - Метод `start()`
        - не может быть вызван более одного раза у одного и того же объекта `Thread`.
        - Если вы хотите выполнить один и тот же код в нескольких потоках, создайте для каждого потока свой объект Thread.
    - Метод `join()`
        - Для того, чтобы основной поток завершался потоком, вызывающим метод `join()`.

            ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4b61062e-bef9-450f-8a14-f57190fb56c9/Untitled.png)

        - Общая форма метода:
        `public final void join() throws InterruptedException`

        ```java
        t1.start(); // запуск потока t1
        t1.join(); // главный поток ожидает завершения t1
        ```

        - По умолчанию программа завершается, когда все ее потоки завершаются.
    - Метод `setDaemon()`
        - Некоторые потоки можно сделать “демонами” (т.е. фоновыми процессами), и тогда они не учитываются при определении необходимости завершения программы
    - Метод `sleep()`
        - останавливает выполнение текущего потока на указанное количество миллисекунд.
        - Этот метод может генерировать исключение `InterruptedException`.
        - Это исключение используется для остановки потоков; как правило, если вы его поймали, текущий поток нужно завершить.
        - `sleep()` - это метод класса `Thread`, который заставляет этот поток приостанавливать выполнение на определенное время, давая другим потокам возможность выполнить, но при этом сохраняя состояние мониторинга.
        - По истечении указанного времени он автоматически возобновится, и вызов метода сна не освободит объект блокировки.
        - Цель состоит в том, чтобы позволить ЦП дать возможность другим потокам работать.
    - Метод `getState()`
        - NEW – объект Thread был создан, но метод `start` не вызван
        - RUNNABLE – поток запущен и работает
        - TERMINATED – поток завершен
        - BLOCKED – поток ждет освобождения блокировки (блокирование - метод, использующийся для разделения ресурсов для реализации взаимного исключения, например, чтобы один поток мог обратиться в ресурсам, а другие нет)
        - WAITING – поток ждет наступления события без ограничения по времени
        - TIMED_WAITING – поток ждет наступления события с ограничением по времени (пример: `Thread.sleep`)
    - Метод `isAlive()`
        - Метод `isAlive()` предназначен для определения существования (выполнения) потока.
        - Общая форма метода:
        `final boolean isAlive()`
        - Метод возвращает `true`, если поток, для которого вызван метод, еще выполняется. В противном случае он возвращает `false.`
    - Методы `setPriority(), getPriority()`
        - Для потоков выполнения может быть установлен различный приоритет.
        - Потоки с большим приоритетом получают большую часть времени центрального процессора на свое выполнение.
        - Чтобы установить приоритет потоков используются два метода:
            - `setPriority()` — устанавливает значение приоритета потока;
            - `getPriority()` — читает (получает) значение приоритета потока.
        - Общая форма методов:
        `final void setPriority(int level)
         final int getPriority()`
            - level – уровень приоритета, который задается в пределах констант от MIN_PRIORITY к MAX_PRIORITY.
            - Значение MIN_PRIORITY = 1 значение MAX_PRIORITY = 10.
            - Если нужно установить по умолчанию значение приоритета, то для этого используется статическая константа NORM_PRIORITY, которая равна 5.
- 23. Синхронизация потоков. Понятие синхронизации. Блок синхронизации
    - В рамках одного потока могут быть разделяемые потоки.
    - Потоки прекрасно работают, если они не используют `mutable shared` state:
        - `shared` – два или более потока обращаются к одним и тем же данным в памяти
        - `mutable` – данные являются изменяемыми
    - Т.е. все хорошо, если:
        - каждый поток работает со своими изменяемыми данными (данные не являются `shared`)
        - потоки работают с общими неизменяемыми данными (данные не являются `mutable`)
    - Синхронизация – это процесс, который позволяет выполнять все параллельные потоки в программе синхронно.

    > Синхронизация позволяет избежать ошибок согласованности памяти, вызванные из-за непоследовательного доступа к общей памяти.
    >
    - чтобы потоки писатель/читать выполнялись корректно, нужно использовать Блок синхронизации:

        ```java
        synchronized (lock) {
        // код блока
        }
        ```

    1. Блок синхронизации для одного и того же `lock` может выполнять одновременно только один поток
    2. Если поток 2 выполняет блок синхронизации с lock после того, как поток 1 выполнил блок синхронизации с lock, то поток 2 “увидит” все изменения, внесенные потоком 1.
    - Пример:

        ```java
        synchronized (lock) {
        		counter++;
        }
        ```

        - Важны оба свойства блока `synchronized` – и исключение параллельного выполнения, и обеспечение visibility.
        - Блок `synchronized` реализован на основе мониторов.
        - Монитор — это объект, который используется для *взаимоисключающей блокировки*
        - Взаимоисключающая блокировка позволяет владеть монитором только одному объекту-потоку.
        - Каждый объект-поток имеет собственный, неявно связанный с ним, монитор.
        - блок `synchronized` гарантирует атомарность выполнения операции (неделимая операция)
- 24. Использование синхронизации потоков для пары процессов producer/reader (производители/потребители)
    - Например, производитель производит запись в область памяти, а потребитель читает из этой области памяти (писатель и читатель). В таком случае, пока писатель (производитель) пишет, читатель (потребитель) должен ждать.
    - Важно, что и у producer, и у reader используется один и тот же объект `lock` в блоке `synchronized`.
    - При использовании разных объектов никаких гарантий синхронизации нет.
    - Гарантируется, что внутри блока `synchronized` в `reader` будет прочитано то значение поля, которое было записано потоком `producer`.

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/55f8b999-0924-4ff0-b4cf-0e2892123938/Untitled.png)

    - Важны оба свойства блока `synchronized` – и исключение параллельного выполнения, и обеспечение `visibility`.
    - В примере producer/reader нам более важна `visibility`. Для этого мы можем использовать вместо блоков `synchronized` поля с модификатором `volatile`.

    ---

    - Производитель и потребитель — это два отдельных процесса.
    - Оба процесса совместно используют общий буфер или очередь.
    - Производитель постоянно производит определенные данные и помещает их в буфер, тогда как потребитель потребляет эти данные из буфера.
    - *доделать*

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/18c2a2fd-c878-4f48-8862-2b4143018e8e/Untitled.png)

    [https://www.baeldung.com/java-producer-consumer-problem](https://www.baeldung.com/java-producer-consumer-problem)

- 25. Реализация блока synchronized на основе мониторов
    - Блок `synchronized` реализован на основе мониторов.
    - Монитор ****– специальным образом организованный участок кода, в котором не может одновременно находится несколько процессов.
    - Другими словами, ***монитор*** — высокоуровневый механизм взаимодействия и синхронизации процессов, обеспечивающий доступ к разделяемым ресурсам. Подход к синхронизации двух или более компьютерных задач, использующих общий ресурс.
    - Монитор может быть в двух состояниях:
        - **свободен (`released`)**
        - **захвачен (`acquired`)**
    - При входе в блок `synchronized` происходит попытка захвата монитора.
        - Если монитор свободен, то он становится захвачен.
        - Если монитор уже захвачен другим потоком, то текущий поток останавливается и ждет, пока другой поток не освободит монитор.
        - Если монитор захвачен текущим потоком, то он остается захвачен.
        - При выходе из блока `synchronized` монитор освобождается.
        - Если при этом другие потоки ждали освобождения этого монитора, то выбирается один из этих потоков, который захватывает монитор и входит в свой блок `synchronized`.
    - Монитор принадлежит объекту `lock`, а не конкретному блоку `synchronized`.
    - Если два или более блока `synchronized` используют один и тот же `lock`, то они используют один монитор для блокировки.

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ae248f72-be01-452e-ba34-59563f0efae9/Untitled.png)

    - Т1 «захватил» ресурсы, процессы Т2 и Т3 ждут в состоянии BLOCKED.

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3d4f7e7f-874b-4421-8860-193573435b6c/Untitled.png)

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3469335c-64c6-41d1-8c42-e6a009a738af/Untitled.png)

- 26. Метод synchronized (lock), особенности его использования для потоков
    - см. вопрос 23
- как достигается потокобезопасность?
    - с помощью использования неизменяемых объектов
    - с помощью синхронизации
- 27. Синхронизация потоков . Правила happens-before (hb)
    - модификатор `volatile` говорит потоку не кэшировать переменную, а читать/писать напрямую в память
    - happens-before говорит процессору о том, что не нужно менять последовательность команд в коде (сохранить порядок операций)
        - чтобы этого добиться, нужно на переменную, задействованную в последней операции, повесить модификатор `volatile`, чтобы все операции до неё выполнялись в сторогом порядке
    - Правила happens-before (hb):
        1. В рамках одного потока любая операция happens-before любой операцией следующей за ней в исходном коде
        2. Выход из synhronized блока happens-before входа в synhronized блок на том же мониторе
        3. Запись volatile поля happens-before чтение того же самого volatile поля
        4. Завершение метода run экземпляра класса Thread happens-before выхода из метода join()
        5. Вызов метода start() экземпляра класса Thread happens-before начало метода run() экземпляра того же треда
    - Связь happens-before транзитивна, т.е. если X happens-before Y, а Y happens-before Z, то X happens-before Z.
    - Если X happens-before Y, то все изменения, внесенные до операции X, будут видны в коде, следующем за операцией Y.
    - Правила happens-before гарантируют, что при чтении `volatile` поля мы читаем последнее записанное значение.
- 28. Синхронизация потоков. Модификатор полей volatile и его использование
    - модификатор `volatile` говорит потоку не кэшировать переменную, а читать/писать напрямую в память

    ---

    - Правила happens-before гарантируют, что при чтении `volatile` поля мы читаем последнее записанное значение.
    - Упрощенно можно представить, что любое обращение к `volatile` полю завернуто в блок `synchronized`.
    - Но это не гарантирует атомарности операций!
    - Но для примера producer/reader можно использовать `volatile`, так как модификатор `volatilе` накладывает некоторые дополнительные условия на чтение/запись переменной.
    1. Операции чтения/записи `volatile` переменной являются атомарными.
    2. Результат операции записи значения в `volatile` переменную одним потоком, становится виден всем другим потокам, которые используют эту переменную для чтения из нее значения.
    - Переменная `volatile` используется в одном из вариантов реализаций паттерна синглетон.
- 29. Синхронизация потоков. Атомарные операции. Механизм Wait/notify
    - Атомарная операция — операция, которая либо выполняется целиком, либо не выполняется вовсе.
    - Для некоторых случаев удобно использовать классы:

        ```java
        AtomicInteger counter = new AtomicInteger(0);
        // И его аналоги AtomicLong, AtomicBoolean
        ```

    - Это аналоги `volatile` полей, но кроме того они добавляют методы, которые выполняются атомарно:

    ```java
    int newValue = counter.addAndGet(delta); // Аналог “counter += delta”
    int oldValue = counter.getAndAdd(delta); // Аналог “counter += delta”
    int newValue = counter.incrementAndGet(); // Аналог “++counter”
    int oldValue = counter.getAndIncrement(); // Аналог “counter++”
    ```

    - Volatile – наиболее эффективный.

    ---

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1fbfb65d-1af5-48b7-a9ae-8e8377a68aee/Untitled.png)

    - Иногда при взаимодействии потоков встает вопрос об извещении одних потоков о действиях других.
        - `wait()`: освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод `notify()`
        - `notify()`: продолжает работу потока, у которого ранее был вызван метод `wait()`
        - `notifyAll()`: возобновляет работу всех потоков, у которых ранее был вызван метод `wait()`
    - Эти методы можно вызывать только внутри блока **`synchronized (lock)`**.
    - Метод `lock.notify()`, в отличие от `lock.notifyAll()`, будит только один поток.
    - В подавляющем большинстве случаев нужно использовать `notifyAll`, так как результата producer могут ждать несколько потоков reader, и их все нужно уведомить о доступности результата.
    - Есть модификция метода `wait` с заданием максимального времени ожидания: `lock.wait(1000);`
    - Как правило, блок с `wait` проверяет наступление некоторого условия, а блок с `notifyAll` меняет статус этого условия.

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cd3ff87b-6e4a-40e1-a475-e3ec92f853ab/Untitled.png)

    - `lock.wait()` должен вызываться в цикле, так как `wait` может ”просыпаться” не обязательно при наступлении условия, так что его нужно перепроверять при каждом пробуждении.
    - Пример использования

        ```java
        package multithreading;

        public class Example {
            public static void main(String[] args) {
                Message msg = new Message("обработать");
                Waiter waiter = new Waiter(msg);
                new Thread(waiter, "waiter").start();

                Waiter waiter1 = new Waiter(msg);
                new Thread(waiter1, "waiter1").start();

                Notifier notifier = new Notifier(msg);
                new Thread(notifier, "notifier").start();
                System.out.println("Стартовали все потоки");
            }
        }

        class Message {
            // поле, с которым будут работать потоки через вызовы геттеров и сеттеров
            private String msg;

            public Message(String str) {
                this.msg = str;
            }

            public String getMsg() {
                return msg;
            }

            public void setMsg(String str) {
                this.msg = str;
            }

        }

        // класс, который будет ожидать другие потоки, пока они не закончат выполнение
        // В этом классе будет находиться монитор на объекте Message, используя синхронизирующий блок.
        class Waiter implements Runnable {

            private Message msg;

            public Waiter(Message m) {
                this.msg = m;
            }

            @Override
            public void run() {
                String name = Thread.currentThread().getName();
                synchronized (msg) {
                    try {
                        System.out.println(name + " ждем вызов метода notify: " + System.currentTimeMillis());
                        msg.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(name + " был вызов метода notify: " + System.currentTimeMillis());
                    // обработаем наше сообщение
                    System.out.println(name + " : " + msg.getMsg());
                }
            }
        }

        // класс Notifier, который будет обрабатывать объект Message, а затем вызвать метод notify,
        // чтобы разбудить ожидающие объект Message потоки
        class Notifier implements Runnable {

            private Message msg;

            public Notifier(Message msg) {
                this.msg = msg;
            }

            @Override
            public void run() {
                String name = Thread.currentThread().getName();
                System.out.println(name + " стартовал");
                try {
                    Thread.sleep(1000);
                    synchronized (msg) {
                        msg.setMsg(name + " поток Notifier отработал");
                        //msg.notify();
                        msg.notifyAll();
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
        ```

        [https://javadevblog.com/primer-ispol-zovaniya-wait-notify-i-notifyall-v-java.html](https://javadevblog.com/primer-ispol-zovaniya-wait-notify-i-notifyall-v-java.html)

- разница между `sleep()` и `wait()`
    - `sleep()` происходит от класса Thread, а `wait()` - от класса Object;
    - В процессе вызова метода `sleep()` поток не снимает блокировку объекта.
    - Когда вызывается метод `wait()`, поток откажется от блокировки объекта и войдет в пул ожидающих блокировок, ожидая этого объекта.
    - После метода `notify()` этот поток входит в подготовку пула блокировки объектов, получает блокировку объекта и переходит в рабочее состояние
- 30. Синхронизация потоков с использованием классов пакета java.util.concurrent.locks
    - В пакете `java.util.concurrent.locks` есть классы для расширенной поддержки синхронизации.
    - Класс `ReentrantLock` является аналогом блока `synchronized` с некоторыми дополнительными функциями.
    - В новых версиях Java рекомендуется использовать его вместо `synchronized`.
    - Класс `ReentrantReadWriteLock` позволяет блокировать потоки только в случае, когда идет изменение данных, а в случае чтения данных блокировки потоков не происходит.
    - Данные классы блокировок реализуют интерфейс `Lock`, ****который включает в себя в частности методы:
        - `void lock()`: ожидает, пока не будет получена блокировка
        - `void unlock()`: снимает блокировку
- 31. Запуск и прерывание потоков. Приостановка и прерывание выполнения потока
    - Иногда требуется прервать выполнение уже запущенного потока. Например, пользователь нажал кнопку “Выполнить”, задача была запущена, но потом он передумал и нажал “Отмена” – при этом нужно остановить уже запущенную задачу.
    - Долго выполняющиеся задачи часто запускаются в отдельном потоке, поэтому требуется механизм для прерывания потока.
    - Запустить поток можно через наследование или при помощи реализации интерфейса `Runnable` (см. вопрос 21).
    - Механизм прерывания позволит нам решить проблему с засыпанием потока
    - У методов, приостанавливающих выполнение потока, таких как `sleep()`, `wait()` и `join()` есть одна особенность — если во время их выполнения будет вызван метод `interrupt()` этого потока, они, не дожидаясь конца времени ожидания, сгенерируют исключение `InterruptedException`.
    - Прервать поток можно следующим образом:

        ```java
        try {
        		Thread.sleep(5000);
        		t1.interrupt();
         } catch (InterruptedException ex) {
        		// ничего не делаем
        }
        ```

        - Вызов этого метода устанавливает у потока статус, что он прерван (при этом сам вызов этого метода НЕ завершает поток).
        - Сам метод возвращает `true`, если поток может быть прерван, в ином случае возвращается `false`.
    - Поток сам решает, когда ему можно безопасно остановиться в случае, когда он прерван.
    - Для того чтобы поток знал, что его прервали, используется два механизма:
        1. Некоторые методы ожидания (Thread.sleep, Object.wait) выбрасывают `InterruptedException`. Оно выбрасывается, если во время ожидания был вызван метод `interrupt()`
        2. Если поток хочет узнать, что метод `interrupt()` был вызван, он может проверять статус прерывания потока (у каждого потока есть булевское поле, сигнализирующее о том, что поток прерван – interrupted status).
    - Для проверки статуса прерывания текущего потока необходимы методы:
        - `interrupted()`: этот статический метод возвращает `true`, если текущий поток был прерван, и после этого сбрасывает его в `false`, или `false` в противном случае.
        - `isInterrupted()`: этот нестатический метод проверяет статус прерывания текущего потока и не очищает статус прерывания
    - Эти механизмы взаимно исключающие, то есть если метод генерирует `InterruptedException`, то он сбрасывает interrupted status.
    - Приостановить поток можно следующим образом:

        ```java
        try {
        		Thread.sleep(2000);
        		continue;
        } catch (InterruptedException ex) {
        		System.out.println(“Я собираюсь остановиться");
        }
        ```

- 32. Обработка операции прерывания потока
    1. **Случай 1:** вызываем метод ожидания в коде метода `run`:

        ```java
        Runnable code = () -> {
                    try {
                        while (true) {
                            Thread.sleep(1000);
                        }
                    } catch (InterruptedException ex) {
                        return; // Был вызов interrupt(), завершаем выполнение потока
                    }
        };
        ```

    2. **Случай 2:** в коде метода run не используются методы ожидания:

        ```java
        Runnable code = () -> {
        		while (true) {
        				if (Thread.currentThread().isInterrupted())
        						return; // Был вызов interrupt(), завершаем выполнение потока
        				// Другая работа метода...
        		}
        };
        ```

    3. **Случай 3:** вызываем метод ожидания в коде метода, вызываемого из `run`

        ```java
        Runnable code = () -> {
        		try {
        				while (true) {
        						someMethod1();
        				}
        		} catch (InterruptedException ex) {
        				return; // Был вызов interrupt(), завершаем выполнение потока
        		}
        };

        void someMethod1() throws InterruptedException {
        		Thread.sleep(1000); // Просто выкидываем InterruptedException наружу
        }
        ```

        - Если есть возможность выкинуть из метода `InterruptedException` для сигнализации о том, что поток прерван, то лучше всегда ей пользоваться.
        - В этом случае распространение исключения по цепочке вызовов достигнет метода `run` потока, где он поймает это исключение и завершится.
        1. **Случай 4**: вызываем из `run` метод, не вызывающий методов ожидания

            ```java
            Runnable code = () -> {
            		try {
            				while (true) {
            						someMethod1();
            				}
            		} catch (InterruptedException ex) {
            			return; // Был вызов interrupt(), завершаем выполнение потока
            		}
            };
            void someMethod1() throws InterruptedException {
            		if (Thread.interrupted()) throw new InterruptedException();
            }
            ```

            - С помощью шаблона
            `if (Thread.interrupted())
                 throw new InterruptedException();`
            можно превращать `interrupted status` в `InterruptedException`, что, как говорилось, удобно для проброса информации о прерывании по цепочке вызова методов. При этом `interrupted status=false`.
            - К сожалению, не всегда возможно выбросить исключение.

                ```java
                collection.forEach(e -> {
                		// Обработка элемента e
                		if (Thread.interrupted())
                				throw new InterruptedException(); // Нельзя!
                });
                ```

                - Метод `Consumer.accept` не разрешает выбрасывать `InterruptedException`.
        2. **Случай 5**: Возможное решение

            ```java
            collection.forEach(e -> {
            		try {
            				Thread.sleep(1000);
            		} catch (InterruptedException ex) {
            				Thread.currentThread().interrupt();
            				throw new RuntimeException(“Отмена”);
            		}
            });
            ```

    - Если мы поймали InterruptedException, то если мы не останавливаем поток сразу и не пробрасываем исключение дальше, то необходимо установить interrupted status для текущего потока.
    - Это нужно для того, чтобы код, который выполняется далее, знал, что поток прерван  (т.е. так как мы не можем сигнализировать о прерывании с помощью
    `InterruptedException`, мы должны сигнализировать с помощью interrupted `status`).
    - Что будет, если не вызывать `Thread.currentThread().interrupt()`:

        ```java
        someMethod1(() -> {
        		try {
        				Thread.sleep(1000);
        		} catch (InterruptedException ex) {
        				throw new RuntimeException(“Отмена”);
        		}
        });
        void someMethod1(Runnable action) {
        		try {
        				action.run();
        		} catch (RuntimeException ex) {
        				// Информация о прерывании потока утеряна!
        		}
        }
        ```

        - Никогда нельзя ловить и игнорировать `InterruptedException`.
        - если поток невозможно прервать сейчас, нужно как минимум установить interrupted status:
        `Thread.currentThread().interrupt();`
        - Исключение – для тестового или демонстрационного кода;
        - Mожно также игнорировать для потока main.
- 33. Ожидание и присоединение запущенной нити основным потоком управления
    - Присоединить поток можно следующим образом:

        ```java
        t1.start();
        try {
        		t1.join();
        } catch (InterruptedException ex) {
        		// do nothing
        }
        ```

    - Этот метод приостановит выполнение текущего потока до тех пор, пока другой поток не закончит свое выполнение.
    - Если поток прерывается, бросается InterruptedException
    - Вы также можете объединить несколько потоков с текущим потоком, например:

        ```java
        t1.join();
        t2.join();
        t3.join();
        ```

    - `public final synchronized void join(long millis)`
        - Этот метод приостановит выполнение текущего потока на указанное время в миллисекундах.
        - Выполнение этого метода зависит от ОС, поэтому Java не гарантирует, что текущий поток будет ждать указанное вами время.
- 34. Жизненный цикл потока на языке Джава. Состояние потока

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1b8087aa-1601-4919-ada8-37b8ee4c0602/Untitled.png)

    ---

    - Метод `getState` позволяет узнать состояние потока, возвращает константу перечисления – поток будет находиться в одном из состояний, описанных выше.
    - Так как компьютер работает очень быстро, метод не всегда может отображать актуальное состояние потока через мгновение.

    ---

    - Согласно Sun Microsystems, существует четыре состояния жизненного цикла потока Java:
        - **New**  — поток находится в состоянии `New`, когда создается экземпляр объекта класса `Thread`, но метод `start` не вызывается.
        - **Runnable**  — когда для объекта `Thread` был вызван метод `start`. В этом состоянии поток либо ожидает, что планировщик заберет его для выполнения, либо уже запущен. Назовем состояние, когда поток уже выбран для выполнения, “работающим” (**`running`)**.
        - **Non-Runnable(Blocked , Timed-Waiting)** — когда поток жив, то есть объект класса `Thread` существует, но не может быть выбран планировщиком для выполнения. Он временно неактивен.
        - **Terminated** — когда поток завершает выполнение своего метода `run`, он переходит в состояние `terminated` (завершен). На этом этапе задача потока завершается.

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d0884c05-2635-4b20-81f9-40113c4e096d/Untitled.png)

    [https://nuancesprog.ru/p/10254/](https://nuancesprog.ru/p/10254/)

- 35. Многопоточные примитивы и их использование

    См. вопросы выше

    1. Класс `Thread` с методами `start/join`
    2. Блоки `synchronized`
    3. Методы `wait/notify/notifyAll`
    4. Поля с модификатором `volatile`
    5. Классы `util.concurrent.atomic.*`
    6. Классы `util.concurrent.locks.*`
    7. Метод `interrupt()`, `InterruptedException` и `interrupted state`
    - Все это низкоуровневые механизмы работы с потоками.
- 36. Интерфейс Executor в Джава и его использование. ExecutorService
    - Потоки потребляют довольно много ресурсов компьютера:
        - Переключение между потоками занимает заметное время
        - Каждый поток требует отдельного стека вызовов
        - Потоки конкурируют между собой за процессор
        - Запуск потока занимает довольно много времени
        - Операционные системы плохо справляются с ситуациями ~10000 потоков и более
    - Но для некоторых приложений (пример: веб-сервер) требуется одновременная обработка большого количества запросов.
    - Если создавать отдельный поток для каждого запроса, это может быть слишком накладно.
    - Интерфейс `java.util.concurrent.Executor` (Исполнитель) — абстракция для запуска задач. Он может запускать потоки по необходимости.
    - Стандартные реализации интерфейса Executor:
        - **Executors.newSingleThreadExecutor()** по сути то же, что newFixedThreadPool(1). Он нужен тогда, когда нам важно, чтобы задачи выполнялись по очереди.
        - **Executors.newFixedThreadPool(int nThreads)** постоянно держит nThreads потоков (keepAliveTime=∞ , т.е. они не останавливаются).
        - **Executors.newCachedThreadPool()** создает потоки для каждой новой задачи, но если новых задач нет, то он убивает потоки через 1 минуту неактивности.
        - Все они на самом деле возвращают объект класса `ThreadPoolExecutor` – реализацию пула потоков. Он состоит из набора потоков и очереди задач.

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c7a6502b-48a8-499d-812d-36d18a8de8e6/Untitled.png)

        - `ExecutorService` - подинтерфейс класса `Executor`, основывается на отделении создания потоков от их управления, позволяет выполнять задачи в потоках асинхронно, помогает поддерживать пул потоков, назначать им задачи тд
        - `ThreadPoolExecutor` конфигурируется параметрами:
            - corePoolSize – базовое количество потоков
            - maximumPoolSize – максимальное количество потоков
            - keepAliveTime – максимальное время простоя потоков
            - Тип очереди задач
        - При выполнении метода executor.execute:
            - Если количество потоков в пуле меньше `corePoolSize`, то для задачи создается новый поток
            - Если количество потоков в пуле от `corePoolSize` до `maximumPoolSize`, то новый поток создается только тогда, когда очередь заполнена
            - Если количество потоков в пуле больше `corePoolSize` и поток не выполняет задач более чем `keepAliveTime`, то поток останавливается
        - `ExecutorService` представляет собой суб-интерфейс `Executor`, который добавляет функциональность для управления жизненным циклом потоков.
        - Он также включает в себя метод `submit()`, который аналогичен методу `execute()`, но более универсален.
        - Перегруженные версии метода `submit()` могут принимать как выполняемый (`Runnable`), так и вызываемый (`Callable`) объект.
        - Вызываемые объекты аналогичны выполняемым, за тем исключением, что задача, определенная вызываемым объектом, также может возвращать значение. Поэтому, если мы передаем объект `Callable` методу `submit()`, он возвращает объект `Future`.
        - Этот объект можно использовать для получения возвращаемого значения `Callable` и управления статусом как `Callable`, так и `Runnable` задач.
- 37. Интерфейс Future в Джава. Основное назначение использования его в программах
    - Интерфейс Future
        - Интерфейс [java.util.concurrent.Future](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html) описывает API для работы с задачами, результат которых мы планируем получить в будущем: методы получения результата, методы проверки статуса.
        - Для `Future` нас интересует его реализация [java.util.concurrent.FutureTask](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html).
        - То есть это `Task`, который будет выполнен во `Future`.
        - Чем эта реализация ещё интересна, так это тем, что она реализует и `Runnable`.

        ```java
        import java.util.concurrent.Callable;
        import java.util.concurrent.FutureTask;

        public class HelloWorld {

            public static void main(String []args) throws Exception {
                Callable task = () -> {
                    return "Hello, World!";
                };
                FutureTask<String> future = new FutureTask<>(task);
                new Thread(future).start();
                System.out.println(future.get());
            }
        }
        ```

        - мы получаем при помощи метода `get` результат из задачи `task`
        - (!)Важно, что в момент получения результата при помощи метода `get` выполнение становится синхронным.
        - [https://javarush.ru/groups/posts/2065-threadom-java-ne-isportishjh--chastjh-iv---callable-future-i-druzjhja](https://javarush.ru/groups/posts/2065-threadom-java-ne-isportishjh--chastjh-iv---callable-future-i-druzjhja)
    - Не всегда нам достаточно просто запустить задачу и забыть про нее; часто нужно узнать результат ее выполнения.
    - `Future` представляет собой будущий результат выполнения задачи.
    - `Futures` – повышение уровня абстракции поверх примитивов многопоточной работы.
    - Метод `isDone()` возвращает `true`, если задача успешно выполнена, и ее результат можно получить.
    - Если задача еще не выполнена, метод `get` блокирует выполнение текущего потока до тех пор, пока не произойдет одно из:
        - задача выполнится успешно и метод `get` вернет ее результат
        - задача выполнится с исключением и метод `get` выбросит `ExecutionException`
        - задача будет и метод `get` выбросит `CancellationException`
        - текущий поток будет прерван и метод `get` выбросит `InterruptedException`
    - Если задача становится неактуальной, ее можно отменить: `boolean cancelled = f1.cancel(true);`
    - Есть также удобные методы для комбинирования результатов нескольких задач:
        - `invokeAll` - Дожидается завершения всех задач и возвращает список результатов
        - `invokeAny` - Возвращается результат первой завершенной задачи
- 38. Коллекции java.util.concurrent. Состав коллекции. Основные методы

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/12b30fda-beeb-4c1a-88d0-35ed28fbf548/Untitled.png)

    - Интерфейс `BlockingQueue`
        - предназначен для работы из нескольких потоков
        - одни потоки добавляют элементы в хвост, другие забирают из головы очереди (каждый элемент достается только одному потоку)

        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6d8862be-0c25-42fe-bcc6-cb271ac87f50/Untitled.png)

    - Классы, реализующие интерфейс `BlockingQueue`
        - **LinkedBlockingQueue**: на основе двусвязного списка, размер может быть неограничен
        - **ArrayBlockingQueue**: на основе массива, размер фиксирован
        - **SynchronousQueue**: очередь “нулевой длины”; добавление элемента в хвост блокируется, пока другой поток не заберет этот элемент из головы
        - Другие интерфейсы, связанные с очередями:
        - **TransferQueue** – блокирующая очередь с подтверждением доставки
        - **BlockingDeque** – блокирующая двусторонняя очередь
        - Другие классы, связанные с очередями:
        - **ConcurrentLinkedQueue** – неблокирующая очередь
        - **ConcurrentLinkedDeque** – неблокирующая двусторонняя очередь
        - **DelayQueue** – блокирующая очередь с задержкой
        - **LinkedBlockingDeque** – блокирующая двусторонняя очередь
        - **LinkedTransferQueue** – блокирующая очередь с подтверждением доставки
        - **PriorityBlockingQueue** – блокирующая отсортированная очередь
    - Semaphore
        - Семафор используется для блокировки доступа на уровне потока к некоторой части физического или логического ресурса.
        - Семафор содержит набор разрешений
        - Всякий раз, когда поток пытается войти в критическую секцию, он должен проверить семафор, доступно ли разрешение или нет
        -
    - Кроме очередей, в java.util.concurrent есть и другие потокобезопасные коллекции:
        - см. вопрос №39
- 39. Потокобезопасные коллекции пакета java.util.concurrent:
    - **`ConcurrentSkipListSet**` – Потокобезопасный аналог TreeSet
    - **`CopyOnWriteArrayList**` – Потокобезопасный аналог ArrayList
    - **`CopyOnWriteArraySet<E>-`** Потокобезопасный сет
    - `ConcurrentMap` и реализации:
        - `ConcurrentHashMap` – потокобезопасный  аналог `HashMap`
        - **`ConcurrentNavigableMap<K,V>` -** Расширяет интерфейс NavigableMap и вынуждает использовать ConcurrentNavigableMap объекты в качестве возвращаемых значений
        - `ConcurrentSkipListMap` – потокобезопасный аналог `TreeMap`
        - **`ConcurrentSkipListSet<E>` -** Имплементация Set интерфейса, выполненная на основе ConcurrentSkipListMap.
    - Наиболее полезным является класс `ConcurrentHashMap` – он позволяет делать кэши, которые можно использовать из нескольких потоков.
    - Класс `ConcurrentHashMap` оптимизирован для использования многими потоками:
        - если несколько потоков только читают данные из него, то они не блокируются;
        - только при одновременной записи в `ConcurrentHashMap` возможна блокировка потоков, но и при этом если запись идет в разные buckets, то они не блокируются друг с другом.
    - Нужно помнить, что только каждый отдельный метод потокобезопасных коллекций является атомарным!
- 40. Реализация асинхронного выполнения в Джава
    - Первый способ реализовать асинхронность в Java  —  воспользоваться интерфейсом `Runnable` и классом потока `Thread`, который доступен начиная с JDK 1.0. Любой класс может реализовать `Runnable` и переопределить метод `run()` либо расширить класс `Thread` и сделать то же самое.
    - Разница в том, что когда метод `run` вызывается непосредственно из `Runnable`, не создается новый поток, а метод выполняется в потоке, откуда вызван. Однако, если мы воспользуемся `thread.start()`, будет создан новый поток.
    - Для лучшего управления потоками в JDK 1.5 можно задействовать исполнителей (`Executor`). Они используют разные пулы потоков и помогают избежать необходимости вручную создавать поток. Вместо этого можно указать, сколько потоков нам нужно, и исполнитель будет переиспользовать эти потоки в течение всего времени запуска приложения.

        ![https://cdn-images-1.medium.com/max/533/1*WjqrxDBEA-D4RaRFmd3akQ.png](https://cdn-images-1.medium.com/max/533/1*WjqrxDBEA-D4RaRFmd3akQ.png)


    ### **Асинхронность с Future**

    - *`run()`*—  это void-метод, и он не может ничего возвращать из потока, но если нам нужен результат вычисления, выполняемого в другом потоке, чем `main`, то нужно будет воспользоваться интерфейсом `Callable`. Ответ от задачи недоступен немедленно, и в качестве альтернативы `Callable` вернет будущий объект `Future`, когда он будет отправлен в службу выполнения. Этот объект обещает, что, когда вычисления завершатся, мы получим их результат  —  достаточно только вызвать `get()`. Это не очень хорошее применение асинхронности, так как `get()` блокирует текущий поток до тех пор, пока не получит ответ. Однако существует обходной путь через метод `future.isDone()`  —  он постоянно проверяет, завершено ли вычисление, и только когда этот метод вернет значение `true`, `get()` возвратит результат.

        ![https://cdn-images-1.medium.com/max/533/1*K-DMbpiMDWd0K0dHVGciMw.png](https://cdn-images-1.medium.com/max/533/1*K-DMbpiMDWd0K0dHVGciMw.png)


    ### **Асинхронность с CompletableFuture**

    - В JDK 1.8 объект Future получил обновление и стал объектом `CompletableFuture`, который, помимо будущего объекта, также реализует этап завершения (`CompletionStage`). `CompletionStage` предлагает множество методов для упрощения работы с ответами, вычисленными в разных потоках и этапах. Некоторые из наиболее распространенных  —  это *`thenApply()`*, аналогичная функции `map()` из потоков, а также *`thenAccept()`*, аналогичная функции `foreach`. Существует несколько способов получить ответ `CompletableFuture`. Одни выполняют задачу в другом потоке, другие нет, но их объединяет одно  —  если во время вычисления возникнут исключения, пользователи могут обрабатывать их.

        ![https://cdn-images-1.medium.com/max/533/1*2lyyzkNOYyg-84htMjfX9g.png](https://cdn-images-1.medium.com/max/533/1*2lyyzkNOYyg-84htMjfX9g.png)

- 41. Паттерн “Одиночка” (Singleton) и его использование в Джава программах
    - см. примеры задач (1)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1f529646-52fe-424c-bd2e-2cad2b11cfcc/Untitled.png)

---

- 42. Использование статических методов для создания экземпляра объекта вместо конструкторов
    - преимущества:
        - говорящее имя метода, подсказывающее порядок параметров, что отличает его от конструктора
        - не обязаны создавать новые объекты при каждом вызове метода, что позволяет неизменяемым классам использовать предварительно конструированные экземпляры или кешировать
        экземпляры при их создании, чтобы избежать создания ненужных дубликатов объектов
        - метод может кешировать объекты
        - статический фабричный метод может возвращать объект любого подтипа их возвращаемого типа, что дает большую гибкость в выборе класса возвращаемого объекта
    - недостатки:
        - если создание объектов доступно только через фабричный метод, создание классов-наследников невозможно
        - трудно отличить от других статических методов
- 43. Паттерн “Строитель” и его использование большом количестве параметров конструктора
    - см примеры задач
    - [https://habr.com/ru/company/otus/blog/552412/](https://habr.com/ru/company/otus/blog/552412/)
- 44. Понятие dependency injection (внедрение зависимости). Преимущества использования внедрения зависимостей при написании программ на языке Джава. Преимущества этого подхода перед паттерном Одиночка (Singleton)
    - Внедрение зависимости - это стиль настройки объекта, при котором поля объекта задаются внешней сущностью. Другими словами, объекты настраиваются
    внешними объектами.
    - DI — это альтернатива самонастройке объектов.
    - Преимущества при написании программ на языке Джава
        - Помогает в модульном тестировании
        - Количество шаблонного кода сокращается, поскольку инициализация **зависимостей** выполняется компонентом инжектора;
        - Расширение приложения становится еще проще;
        - Помогает уменьшить связность кода, что важно при разработке приложений.
    - Преимущества перед Singleton
        - Почему вам следовало бы избегать паттерн Singleton (Одиночка) и вместо него использовать Dependency Injection (Инъекция зависимости)?
        - Например, каждый класс, которому нужен доступ к общему объекту, получает ссылку на него через свой конструктор или через DI-контейнер.
        - Чем больше классов вызывают метод `getInstance`, тем больше код становится сильно связным (tightly coupled), монолитным, не тестируемым и сложным для изменений и повторного использования из-за неконфигурируемых скрытых зависимостей.

        ### **Сильная связность (tight coupling)**

        Поскольку синглтон предоставляет глобальный статус другим классам, он очень часто используется во многих местах в коде. Это превращает синглтон в центральное место вашего приложения от которого напрямую или косвенно зависит остальной код. Конкретный модуль может быть сложно переиспользовать и тестировать, т.к. зависимые модули так же должны быть включены.

        ### **Сложности с тестированием**

        Поскольку фабричный метод (`getInstance`) глобально доступный, вы вызываете его с именем класса, вместо того, что бы полагаться на интерфейс, который позже вы можете заменить другой реализацией или mock. Вот почему невозможно заменить его, когда вы хотите протестировать метод или класс.

        ### **Синглтон сохраняет состояние пока приложение выполняется**

        Постоянное состояние – враг юнит-тестирования. Одной из причин эффективности юнит-тестирования является независимость каждого теста от других. Если это не так, то очередность, в которой выполняются тесты, влияет на результаты их выполнения. Это может приводить к случаям, когда тесты завершаются с ошибкой, хотя не должны, а так же может приводить к успешно выполненным тестам, что даже хуже.

    - источник - [https://poltora.info/ru/blog/vse-chto-vi-hoteli-znat-o-singleton/](https://poltora.info/ru/blog/vse-chto-vi-hoteli-znat-o-singleton/)
- 45. Преимущество использования try-с-ресурсами по сравнению с использованием try-finally. Интерфейс интерфейса AutoCloseable
    - try-с-ресурсами
        - Ресурс — это объект, который должен быть закрыт после того, как программа закончит с ним работу
        - «`try` c ресурсами» берет всю работу по закрытию ресурсов на себя
        - Преимущество перед  try-finally
            - Предположим нам нужно написать метод, который считывает первую строчку из одного файла и записывает ее в другой файл:

            ```java
            public void rwLine(Path pathRead, Path pathWrite) throws IOException{
                    BufferedReader in = null;
                    BufferedWriter out = null;
                    try{
                        in = Files.newBufferedReader(pathRead);
                        out = Files.newBufferedWriter(pathWrite);
                        out.write(in.readLine());
                    } finally {
                        if (in != null) in.close();
                        if (out != null) out.close();
                    }
            }
            ```

            1. Слишком много кода для столь простой операции
            2. если при закрытии первого ресурса (`if (in != null) in.close()`) будет сгенерировано исключение, то второй ресурс закрыт не будет (**`if** (out != **null**) out.close();`)
            - Можно избежать данной ошибки таким путём, однако это очень громоздкая конструкция:

            ```java
            finally {
                        try{
                            if (in != null) in.close();
                        } catch(IOException e){

                        }
                        try{
                            if (out != null) out.close();
                        } catch(IOException e){

                        }

             }
            ```

            - Вывод: try-с-ресурсами требует намного меньше кода, чем try-finally, а также не нужно переживать об обработке закрытия ресурсов, так как он сделает это сам
        - Общий вид:

            ```java
            try(BufferedReader reader = Files.newBufferedReader(path1);
                            BufferedWriter writer = Files.newBufferedWriter(path2)){

                    } catch(IOException){

                    } finally{

                    }
            ```

            - Главное отличие от привычного блока [try](https://docs.oracle.com/javase/tutorial/essential/exceptions/try.html) в круглых скобках, в которых создаются ресурсы, которые впоследствии нужно закрыть, ресурсы будут закрываться снизу-вверх автоматически после завершения работы блока [try](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html), т.е. в примере, сначала закроется ***writer***, а потом ***reader***.
            - Ресурсы созданные в блоке [try()](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html), в нашем случае ***reader*** и ***writer*** будут видны только в блоке [try](https://docs.oracle.com/javase/tutorial/essential/exceptions/try.html) , в блоках [catch](https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html) и [finally](https://docs.oracle.com/javase/tutorial/essential/exceptions/finally.html) попытка их использования вызовет ошибку компиляции.
            - В try-с-ресурсами не обязательно использовать блоки [catch](https://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html) и [finally](https://docs.oracle.com/javase/tutorial/essential/exceptions/finally.html), они являются опциональными
            - Пример
                - копирование первой строчки файла в другой файл

                ```java
                public void rwLine(Path pathRead, Path pathWrite) throws IOException{
                        try(BufferedReader in = Files.newBufferedReader(pathRead);
                                BufferedWriter out = Files.newBufferedWriter(pathWrite);){
                            out.write(in.readLine());
                        }
                    }
                ```

    - AutoCloseable
        - Для того, чтобы класс можно было использовать в операторе [try с ресурсами](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html), он должен реализовывать интерфейс [AutoCloseable](https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html).
        - Необходимо реализовать всего лишь один метод – [public void close() throws Exception](https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html#close--).

        ```java
        public class Example implements AutoCloseable{
            public static void main(String[] args){
                try(Example ex = new Example()){
                    System.out.println("Try");
                }
            }

            @Override
            public void close(){
                System.out.println("Close");
            }
        }
        ```

        - сначала выполнился код из блока [try](https://docs.oracle.com/javase/tutorial/essential/exceptions/try.html), а потом произошло закрытие ресурса, с помощью переопределенного метода [close()](https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html#close--).

        <aside>
        💡 Метод [close()](https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html#close--) не должен содержать никакой бизнес логики, только закрытие ресурсов

        </aside>

    - [https://javanerd.ru/основы-java/try-с-ресурсами/](https://javanerd.ru/%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-java/try-%D1%81-%D1%80%D0%B5%D1%81%D1%83%D1%80%D1%81%D0%B0%D0%BC%D0%B8/)
- 46. Паттерн Декоратор (Decorator). Преимущества его использовании (например композиция по сравнению с наследованием)
    - см примеры задач
    - [https://javarush.ru/groups/posts/3426-pattern-dekorator-decorator](https://javarush.ru/groups/posts/3426-pattern-dekorator-decorator)
- 47. Преимущества использования списков перед массивами
    1. Списки (List) в Java - абстрактный интерфейс, что позволяет наследовать различные виды списков, такие как ArrayList, LinkedList и тд
    2. Не фиксированы по размеру, в отличие от массивов
    3. Быстрое добавление и удаление элемента на любую позицию
- 48. Основные системы сборки Gradle и Maven. Использование Gradle и основная терминология. Управление зависимостями в Gradle
    - 36.Система сборки Gradle
        - **Gradle** — система автоматической сборки, которую используют для упрощения работы с Java. С помощью (условно) стандартизированных средств она помогает разработчикам собрать нужный продукт без потери его уникальности.
        - Gradle не привязан к конкретной платформе. К тому же, в системе используют разные языки программирования. Наиболее популярные — **Groovy DSL и Kotlin** (но можно писать и на других).
        - **Управление зависимостями** — указание библиотек или фреймворков, которые нужны проекту. Gradle должна включить эти зависимости в определённый момент, чтобы в конце собрать приложение корректно (или вообще). Команда gradle init для java-application в build-скрипте автоматически вызывает информацию о 2 конфигурациях.
        - Статья - [https://habr.com/en/post/473642/](https://habr.com/en/post/473642/)
    - Лекция 5 - ШППЯД
    - см приложение в конце страницы
- 49. Анатомия jar. Сканирование пакетов
    - `Jar` это `zip` архив специального вида!
    - Внутри `jar` находятся байт код программы, ресурсы а также сохранена переменная `classpath` для данной программы.

    <aside>
    💡 Напоминание! `Classpath` это переменная, в которой указаны пути до всех классов программы и самое главное мэин класс.

    </aside>

    - источник - лекция шппяд
- 50. Реализация REST API с помощью Spring Framework
    - `REST` – стиль взаимодействия клиента с сервером.
    - Обычно онподразумевает запросы и ответы в формате `JSON`, где адресзапроса содержит информацию о том, что хочет сделать клиент

    ```java
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    @SpringBootApplication
    public class RestApp {
    		public static void main(String[] args) {
    				SpringApplication.run(RestApp.class, args);
    		}
    }
    ```

    ```java
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;

    @RestController
    @RequestMapping(produces = "application/json")
    public class RestHello {
    		@GetMapping("/hello")
    		public String hello(@RequestParam(defaultValue = "world") String name) {
    				return String.format("Hello, %s!", name);
    		}
    }
    ```

    - логика работы во многом задается аннотациями
    - главный класс RestApp никак не ссылается на класс
    RestHello
    - Аннотации `@RestController`
        - `@GetMapping`/`@PostMapping`/`@PutMapping`/
        `@DeleteMapping` - частные случаи `@RequestMapping`
        - `@RequestParam` – описывает параметр, значение которого берется из строки запроса (?name=...)
        - `@PathVariable` – описывает параметр, значение которого берется из пути запросa
        - Пример использования `@PathVariable`:

            ```java
            @GetMapping("/api/books/{bookId}")
            public Book getBook(@PathVariable("bookId") int bookId)
            ```

    - Как тестировать REST API?
        - встроенный в IntelliJ IDEA клиент HTTP
        - curl – утилита командной строки
        - Postman
    - источник - Лекция 6 - ШППЯД - [https://github.com/osobolev/restdemo/tree/master/src/main/java/ru/mirea/books](https://github.com/osobolev/restdemo/tree/master/src/main/java/ru/mirea/books)
    - [https://habr.com/ru/post/435144/](https://habr.com/ru/post/435144/) дополнительно
- 51. Понятие Инверсии управления
    - Inversion of control (инверсия контроля) - это определенный набор рекомендаций, позволяющих проектировать и реализовывать приложения используя слабое связывание отдельных компонентов.
    - То есть, для того чтобы следовать принципам инверсии управления необходимо:
        - Реализовывать компоненты, отвечающие за одну конкретную задачу;
        - Компоненты должны быть максимально независимыми друг от друга;
        - Компоненты не должны зависеть от конкретной реализации друг друга.
- 52. Spring Boot и его использование
    - **Spring Boot - это фреймворк, который** позволяет разработчикам настраивать и запускать автономные приложения **Spring** производственного уровня без их развертывания на веб-сервере.
    - Чтобы запустить обычное Java-приложение, **его** необходимо упаковать, выбрать, загрузить и настроить веб-сервер, а также организовать процесс развертывания.
    - Если `Spring Framework` фокусируется на предоставлении гибкости, то **`Spring Boot`** стремится сократить длину кода и упростить разработку web-приложения.
    - Используя конфигурацию при помощи аннотаций и стандартного кода, `Spring Boot` сокращает время, затрачиваемое на разработку приложений.
    - [http://spring-projects.ru/guides/spring-boot/](http://spring-projects.ru/guides/spring-boot/)
    - [https://topjava.ru/blog/introducing-spring-boot](https://topjava.ru/blog/introducing-spring-boot)
    - Пример приложения
    Анатомия простого примера приложения Spring Boot:
    [https://spring.io/guides/gs/rest-service/](https://spring.io/guides/gs/rest-service/)
- 53. Работа с базами данных в джава приложениях. Встроенные СУБД для Джава приложений
    - H2
        - Приложение H2 Console позволяет получить доступ к базе данных с помощью браузера.
        - Это может быть база данных H2 или другая база данных, поддерживающая JDBC API.

        ```java
        import java.sql.*;
        public class Test {
        public static void main(String[] a) throws Exception {
        		Connection conn = DriverManager.getConnection("jdbc:h2:~/test", "sa", "");
        		// add application code here
        		conn.close();
        		}
        }
        ```

    - Apache Derby
        - Derby — это чистый Java, основанный на стандартах механизм реляционной базы данных.
        - Derby стремится стать простым в использовании решением для управления данными для разработчиков программного обеспечения с нулевым администрированием для конечных пользователей.
        - Apache Derby взаимодействует с API Java Cryptography Extension (JCE) для предоставления
        - Полное шифрование файлов базы данных на диске
        - Хранение и аутентификация паролей пользователей, хранящихся в базе данных
        - Шифрование пользователя и пароля по сети
        - оригинал на английском

            Derby is a pure Java, standards-based relational database engine.

            Derby aims to be an easy to use solution for data management for software developers with zero administration for end users.

            Apache Derby interfaces with the Java Cryptography Extension (JCE) API to provide

            - Full on-disk encryption of database files
            - Storage and authentication of user passwords stored in the database
            - User and password encryption over a network

            [https://github.com/apache/derby?ref=stackshare](https://github.com/apache/derby?ref=stackshare)

    - источник - лекция 7 шппяд
- 54. Реляционные СУБД для работы с джава приложениями. Пакет java.sql и его классы
    - Клиент-серверные СУБД (системы управления базами данных):
        - PostgreSQL
        - Oracle
        - MySQL
        - Microsoft SQL Server
    - Пакет java.sql – классы JDBC (Java Database Connectivity –соединение с БД на Java):
        - Connection
        - PreparedStatement
        - ResultSet
        - SQLException
        - DriverManager
        - …
    - источнник - лк 7 шппяд
- 55. Роль интерфейса JDBC для работы с джава приложениями
    - **JDBC (Java DataBase Connectivity)** – позволяет получать доступ к БД, а также выполнять к ней SQL запросы.
    - Концепция JDBC – драйверы позволяющих получать соединение с базой данных по специально описанному URL.
- 56. Основные компоненты JDBC API

    ### 1. DriverManager

    Это класс, использующийся для управления списком `Driver` (database drivers).

    ### 2. Driver

    Это интерфейс, использующийся для соединения коммуникации с базой данных, управления коммуникации с базой данных.

    ### 3. Connection

    Интерфейс со всеми методами связи с базой данных. Он описывает коммуникационный контекст. Вся связь с базой данных осуществляется только через объект соединения (connection).

    ### 4. Statement

    Это интерфейс, включающий команду `SQL`отправленный в базу данных для анализа, обобщения, планирования и выполнения.

    ### 5. ResultSet

    `ResultSet` представляет набор записей, извлеченных из-за выполнения запроса.

    - источнник - лк 7 шппяд
- 57. JDBC URL и его использование
    - Обычно URL-адреса соединения выглядят следующим образом:
        - `jdbc:sqlserver://[serverName[\instanceName][:portNumber]][;property=value[;property=value]]`

        где:

        - **jdbc:sqlserver://** (обязательно) известен как подпротокол и является константой.
        - **serverName** (необязательно) является адресом сервера, с которым выполняется соединение.
            - Это может быть DNS, IP-адрес, localhost или адрес 127.0.0.1 локального компьютера.
            - Имя сервера необходимо указать в коллекции свойств, если оно не указано в URL-адресе соединения.
        - **instanceName** (необязательно) является экземпляром, с которым выполняется соединение с serverName.
            - Подключение выполняется к экземпляру по умолчанию, если не указано другое.
        - **portNumber** (необязательно) является портом, с которым выполняется соединение с serverName.
            - Значение по умолчанию — 1433.
            - Если соединение выполняется с портом по умолчанию, в URL-адресе необязательно указывать порт или символ ':' перед ним.
        - **property** (необязательно) представляет собой одно или несколько свойств соединений.
            - Можно указать любое свойство из списка.
            - В качестве разделителей в списке свойств можно использовать точку с запятой (';'), при этом свойства не могут повторяться.
    - Использование
        - PostgreSQL: jdbc:postgresql://localhost:5432/postgres
        - Oracle: jdbc:oracle:thin:@[//localhost:1521/orcl](notion://localhost/orcl)
        - H2: jdbc:h2:~/example_db
        - H2 – встроенная СУБД:

            ```groovy
            dependencies {
            	runtimeOnly("com.h2database:h2:1.4.200")
            }
            ```

            - `Connection c = DriverManager.getConnection("jdbc:h2:~/example_db")`
        - источник - лк 7 шппяд
- 58. Работа JDBC драйвера
    - JDBC-драйвер (J*ava DataBase Connectivity*) – библиотека для выполнения SQL-запросов для конкретной БД
    - **JDBC-драйвер** – реализация JDBC для определенной базы данных.
    - В приложении может быть зарегистрировано несколько разных драйверов.
    - При соединении к базе, нужный выбирается исходя из URL соединения.
    - Например, для `jdbc:mysql://localhost:3306/db_name` будет использован MySQL JDBC драйвер (при наличии).
    - Как подключить JDBC?
        1. Импортировать пакет **JDBC** в наш Java код.
        2. Зарегистрировать **JDBC** драйвер.
        3. Передать информацию для соединения с БД (URL, имя пользователя и пароль).
        4. Создать соединение с помощью метода `getConnection()`.

    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d6315c83-aa67-4838-8e2e-5a28d4169047/Untitled.png)

- 59. В чем заключается роль DI в Spring. Использования ServiceLoader
    - Dependency injection
        - **Внедрение зависимостей** — это стиль настройки объекта, при котором поля объекта задаются внешней сущностью. Другими словами, объекты настраиваются внешними объектами.
        - DI — это альтернатива самонастройке объектов.
        - Внедрение зависимостей — это способ обработки зависимостей вне зависимого класса, когда зависимому классу не нужно ничего делать.
        - В том случае, когда класс разрешает собственные зависимости, он становится негибким в отношении к этим зависимостям. Это плохо. Это значит, что если вам нужно поменять зависимости, вам нужно поменять код. Это означает то, что если вам нужно использовать другую базу данных, вам потребуется поменять класс. Если у вас много классов, реализованных таким образом, вам придется изменять их все.
    - ServiceLoader
        - [ServiceLoader](https://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html) предоставляет возможность поиска и создания зарегистрированных экземпляров интерфейсов или абстрактных классов. Это очень похоже на аннотации [Bean](https://www.baeldung.com/spring-bean-annotations) и [Autowired](https://www.baeldung.com/spring-autowire) в Spring.

        ```java
        public class ServiceLoaderExample {

           public static void main(String [] args) {
               final ServiceLoader<SimpleService> services = ServiceLoader.load(SimpleService.class);
               for (SimpleService service : services) {
                   System.out.println("Echo: " + service.echo(args[0]));
               }
           }
        }
        ```

        - Метод `ServiceLoader.load`  вызывается для получения `ServiceLoader`, который можно использовать для получения экземпляров сервиса.
        - Экземпляр `ServiceLoader` реализует интерфейс `Iterable` для типа сервиса, следовательно, переменную `services`  можно использовать в цикле `for each`
        - Преимущества `ServiceLoader`

            ### **Скорость**

            Для консольных приложений время запуска ServiceLoader **НАМНОГО м**еньше, чем Spring Boot App. Это благодаря меньшему количеству загружаемого кода, отсутствию сканирования, отсутствию рефлекшена, отсутствию больших фреймворков.

            ### **Память**

            Spring не славится тем, что экономит память. Если вам важно расходование памяти, то следует рассмотреть возможность использования ServiceLoader для DI.

            ## **Модули Java**

            Одним из ключевых аспектов Java-модулей была возможность полностью защитить классы в модуле от кода вне модуля. ServiceLoader — это механизм, который позволяет внешнему коду «обращаться» к внутренним реализациям. Модули Java позволяют регистрировать сервисы для внутренних реализаций, сохраняя при этом границу.

            Фактически, это единственный официально одобренный механизм поддержки внедрения зависимостей для Java-модулей. Spring и большинство других DI-фреймворков используют reflection для поиска и подключения своих компонент. Но это не совместимо с Java-модулями. Даже reflection не может заглянуть в модули (если вы это не разрешите, но зачем вам разрешать).

        - В отличие от `Spring` у `ServiceLoader` не так много функционала, однако он простой, маленький, быстрый и всегда доступен.
    - Что использовать тогда? Итоги
        - Spring — отличная штука, но бывают случаи, когда ServiceLoader будет правильным выбором.
        - Скорость
        Для консольных приложений время запуска
        ServiceLoader НАМНОГО меньше, чем Spring Boot App.
        - Память
        Если вам важно расходование памяти, то следует рассмотреть возможность использования ServiceLoader для DI.
        - Модули Java
        Одним из ключевых аспектов Java-модулей была возможность полностью защитить классы в модуле от кода вне модуля.
        - источник - лк 7 шппяд
- 60. Интерфейс Connection. Пулы соединений
    - Connection interface
        - source - [https://java-online.ru/jdbc-connection.xhtml](https://java-online.ru/jdbc-connection.xhtml)
        - Для соединения с БД необходимо использовать класс `Connection` пакета java.sql.
        - После установления соединения можно выполнять различные SQL-запросы и получать результаты их обработки сервером.
        - Приложение может открыть одно или несколько соединений с одной или несколькими различными СУБД.
        - Стандартный способ установления соединения - это вызов метода `getConnection` класса `DriverManager`.
        - Методу `getConnection` необходимо передать строку URL (Uniform Resource Locator).
        - Стандарт подключения к серверу базы данных позволяет использовать следующие методы `getConnection` с параметрами:

            ```
            getConnection(url);
            getConnection(url, properties);
            getConnection(url, username, password);
            ```

        - ****Подключение к СУБД PostgreSQL, jdbc postgresql****
            - Для подключения к серверу БД PostgreSQL необходимо использовать один из следующих URL:

                ```
                jdbc:postgresql:database

                jdbc:postgresql://host/database

                jdbc:postgresql://host:port/database

                jdbc:postgresql://host:port
                ```

                - host - имя сервера, по умолчанию "localhost".
                - port - порт, который слушает сервер. По умолчанию используется порт 5432.
                - database - наименование базы данных. По умолчанию используется база данных postgres.
            - ****Примеры jdbc postgresql :****

                ```
                String url1 = "jdbc:postgresql://localhost/test?user=postgres&password=secret&ssl=true";
                String url2 = "jdbc:postgresql://localhost/test";

                String user = "postgres";
                String pwd  = "secret";

                Properties props = new Properties ();
                props.setProperty("user"    , user );
                props.setProperty("password", pwd  );
                props.setProperty("ssl"     ,"true");

                Connection connection1 = DriverManager.getConnection(url1);
                Connection connection2 = DriverManager.getConnection(url2, props);
                Connection connection3 = DriverManager.getConnection(url2, user, pwd);
                ```

        - Подключение к ****СУБД MySQL, jdbc mysql****

            ```
            String driver   = "com.mysql.jdbc.Driver";
            String url      = "jdbc:mysql://localhost:3306/";
            String dbName   = "...";
            String userName = "...";
            String password = "...";
            try {
                Class.forName(driver).newInstance();
            	Connection conn = DriverManager.getConnection(url + dbName, userName, password);
            	if (conn != null)
            		System.out.println ("Приложение подключилось к БД !");
            	else
            		System.out.println ("Приложение НЕ подключилось к БД ?");

                conn.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
            ```


    - Интерфейс `Connection` описывает активное соединение с БД (в случае клиент-серверной БД – это
    сетевое соединение).

    ```java
    public class BookRepository {
    		public List<Book> getAllBooks() {
    				try (Connection connection = ???) {
    				}
    		}
    }
    ```

    - Плохие варианты работы с соединением
        1. Открывать соединение каждый раз в методах
        `BookRepository:`
            1. `Connection connection = DriverManager.getConnection("...")`
            2. Соединение открывается медленно (порядка 0.1 секунд). Наше приложение не будет справляться с большой нагрузкой
        2. Держать `Connection` в поле `BookRepository`.
            1. Как правило, только один поток может одновременно работать с одним соединением. Хотя соединения обычно потокобезопасны, но это достигается с помощью синхронизации.
            2. Поэтому при большом количестве параллельных запросов к `BookRepository` только один из них будет работать, остальные будут ждать
    - Пул соединений — это хорошо известный шаблон доступа к данным, основная цель которого — уменьшить накладные расходы, связанные с выполнением соединений с базой данных и операциями чтения/записи базы данных.
    - Пул соединений с базой данных это набор заранее
    открытых соединений с базой данных используемый
    для предоставления соединения в тот момент, когда
    оно требуется.
    - Пул с максимальным количеством соединений = 20 позволяет параллельно работать с БД 20 потокам.
    - При этом соединения не закрываются, а по возможности переиспользуются.
    - Интерфейс `javax.sql.DataSource` задает абстракцию
    пула соединений:

        ```java
        public interface DataSource {
        		Connection getConnection();
        }
        ```

    - Для возврата соединения в пул можно его закрыть – при этом реально соединение с БД не закрывается (т.к. `DataSource` возвращает не `org.h2.jdbc.JdbcConnection`, а "обертку", которая реализует `java.sql.Connection` и перенаправляет вызовы методов `org.h2.jdbc.JdbcConnection`, кроме метода `close`).

        ```java
        public class MyPooledConnection implements Connection {
        		private final Connection realConnection;
        		private final MyPool pool;

        		public PreparedStatement prepareStatement(String sql) {
        				return realConnection.prepareStatement(sql);
        		}

        		public void close() {
        				pool.free(realConnection);
        		}
        }
        ```

    - Есть несколько реализаций пулов соединений:
    • HikariCP
    • Apache Commons DBCP
    • C3PO

        ```java
        // Пример конфигурации HikariCP:
        HikariConfig config = new HikariConfig();
        config.setAutoCommit(false);
        config.setJdbcUrl("jdbc:h2:~/example_db");
        DataSource dataSource = new HikariDataSource(config);
        ```

- 61. Принципы SOLID и их использование на Джава.
    - Что такое SOLID

        **SOLID — это аббревиатура пяти основных принципов проектирования в объектно-ориентированном программировании — Single responsibility, Open-closed, Liskov substitution, Interface segregation и Dependency inversion. В переводе на русский: принципы единственной ответственности, открытости / закрытости, подстановки Барбары Лисков, разделения интерфейса и инверсии зависимостей)**

        [https://web-creator.ru/articles/solid](https://web-creator.ru/articles/solid) - статья с ссылками на подробности по каждому приинципу

        [https://medium.com/webbdev/solid-4ffc018077da](https://medium.com/webbdev/solid-4ffc018077da) - подробная статья с примерами

        [https://habr.com/ru/company/productivity_inside/blog/505430/](https://habr.com/ru/company/productivity_inside/blog/505430/) - короткая статья

    - 30.Принципы SOLID: принцип единственной ответственности (Single responsibility principle)

        > *Каждый класс должен отвечать только за одну операцию.*
        >
        - Каждый объект должен иметь одну обязанность и эта обязанность должна быть полностью инкапсулирована в класс. Все его сервисы должны быть направлены исключительно на обеспечение этой обязанности.
        - Если класс отвечает за несколько операций сразу, вероятность возникновения багов возрастает – внося изменения, касающиеся одной из операций вы, сами того не подозревая, можете затронуть и другие.
        - Принцип служит для разделения типов поведения, благодаря которому ошибки, вызванные модификациями в одном поведении, не распространялись на прочие, не связанные с ним типы.
    - 31.Принципы SOLID: принцип открытости-закрытости (Open/closed principle)

        > *Классы должны  быть открыты для расширения, но закрыты для модификации.*
        >
        - Программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения. Это означает, что эти сущности могут менять свое поведение без изменения их исходного кода.
        - Когда вы меняете текущее поведение класса, эти изменения сказываются на всех системах, работающих с данным классом. Если хотите, чтобы класс выполнял больше операций, то идеальный вариант – не заменять старые на новые, а добавлять новые к уже существующим.
        - Принцип служит для того, чтобы делать поведение класса более разнообразным, не вмешиваясь в текущие операции, которые он выполняет. Благодаря этому вы избегаете ошибок в тех фрагментах кода, где задействован этот класс.
    - 32.Принципы SOLID: принцип Барбары Лисков (Liskov substitution principle)

        > *Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы.*
        >
        - “функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом”
        - В случаях, когда класс-потомок не способен выполнять те же действия, что и класс-родитель, возникает риск появления ошибок.
        - Необходимо, чтобы класс-потомок был способен обрабатывать те же запросы, что и родитель, и выдавать тот же результат. Или же результат может отличаться, но при этом относиться к тому же типу.
        - Если класс-потомок не удовлетворяет этим требованиям, значит, он слишком сильно отличается от родителя и нарушает принцип.
        - Принцип служит для того, чтобы обеспечить постоянство: класс-родитель и класс-потомок могут использоваться одинаковым образом без нарушения работы программы.
    - 33.Принципы SOLID: принцип разделения интерфейсов (Interface segregation principle)

        > *Не следует ставить клиент в зависимость от методов, которые он не использует.*
        >
        - “Клиенты не должны зависеть от методов, которые они не используют”
        - Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе.
        - В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.
        - Класс должен производить только те операции, которые необходимы для осуществления его функций. Все другие действия следует либо удалить совсем, либо переместить, если есть вероятность, что они понадобятся другому классу в будущем.
        - Принцип служит для того, чтобы раздробить единый набор действий на ряд наборов поменьше – таким образом, каждый класс делает то, что от него действительно требуется, и ничего больше.
    - 34.Принципы SOLID: принцип инверсии зависимостей (Dependency inversion principle)

        > *Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.*
        >
        - Модули (или классы) верхнего уровня = классы, которые выполняют операцию при помощи инструмента
        - Модули (или классы) нижнего уровня = инструменты, которые нужны для выполнения операций
        - Абстракции – представляют интерфейс, соединяющий два класса
        - Детали = специфические характеристики работы инструмента
        - Класс не должен соединяться с инструментом, который применяет для выполнения операции. Вместо этого он должен быть соединён с интерфейсом, который поможет установить связь между инструментом и классом.
        - Ни интерфейс, ни класс, не обязаны вникать в специфику работы инструмента. Напротив, это инструмент должен подходить под требования интерфейса.
        - Принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт введения интерфейсов.


---

> Паттерн – это стандартизированное решение какой-либо часто встречающейся проблемы.
>
- шаблоны проектирования помогают:
    - не изобретать велосипед, а использовать стандартные решения;
    - стандартизировать код;
    - стандартизировать терминологию;

---